import {
  require_node_buffer
} from "./chunk-CWRY33XM.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/read-chunk/node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/read-chunk/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/read-chunk/index.js
async function readChunk(filePath, { length, startPosition }) {
  const fileDescriptor = await fsOpenP(filePath, "r");
  try {
    let [bytesRead, buffer] = await fsReadP(fileDescriptor, {
      buffer: import_node_buffer.Buffer.alloc(length),
      length,
      position: startPosition
    });
    if (bytesRead < length) {
      buffer = buffer.subarray(0, bytesRead);
    }
    return buffer;
  } finally {
    await fsCloseP(fileDescriptor);
  }
}
function readChunkSync(filePath, { length, startPosition }) {
  let buffer = import_node_buffer.Buffer.alloc(length);
  const fileDescriptor = import_node_fs.default.openSync(filePath, "r");
  try {
    const bytesRead = import_node_fs.default.readSync(fileDescriptor, buffer, {
      length,
      position: startPosition
    });
    if (bytesRead < length) {
      buffer = buffer.subarray(0, bytesRead);
    }
    return buffer;
  } finally {
    import_node_fs.default.closeSync(fileDescriptor);
  }
}
var import_node_util, import_node_fs, import_node_buffer, import_pify, fsReadP, fsOpenP, fsCloseP;
var init_read_chunk = __esm({
  "node_modules/read-chunk/index.js"() {
    import_node_util = __toESM(require_node_util());
    import_node_fs = __toESM(require_node_fs());
    import_node_buffer = __toESM(require_node_buffer());
    import_pify = __toESM(require_pify());
    fsReadP = (0, import_pify.default)(import_node_fs.default.read, { multiArgs: true });
    fsOpenP = (0, import_node_util.promisify)(import_node_fs.default.open);
    fsCloseP = (0, import_node_util.promisify)(import_node_fs.default.close);
  }
});
init_read_chunk();
export {
  readChunk,
  readChunkSync
};
//# sourceMappingURL=read-chunk-Y7DVDH64.js.map
