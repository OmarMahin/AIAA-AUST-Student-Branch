import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:fs/promises
var require_promises = __commonJS({
  "browser-external:fs/promises"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs/promises" has been externalized for browser compatibility. Cannot access "fs/promises.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/validate-image-type/lib/image-type.js
var require_image_type = __commonJS({
  "node_modules/validate-image-type/lib/image-type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.imageType = void 0;
    var supportedImageTypes = [
      "jpg",
      "png",
      "gif",
      "webp",
      "flif",
      "cr2",
      "tif",
      "bmp",
      "jxr",
      "psd",
      "ico",
      "bpg",
      "jp2",
      "jpm",
      "jpx",
      "heic",
      "cur",
      "dcm",
      "avif"
    ];
    var imageExts = new Set(supportedImageTypes);
    var imageType = async (buffer) => {
      const { fileTypeFromBuffer } = await import("./browser-C7IDVWBG.js");
      const ret = await fileTypeFromBuffer(buffer);
      if (!ret) {
        return null;
      }
      return imageExts.has(ret.ext) ? ret.mime : null;
    };
    exports.imageType = imageType;
  }
});

// node_modules/validate-image-type/lib/isBinary.js
var require_isBinary = __commonJS({
  "node_modules/validate-image-type/lib/isBinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBinary = exports.BINARY_READ_LENGTH = void 0;
    exports.BINARY_READ_LENGTH = 24;
    var isBinary = (buffer) => {
      for (let i = 0; i < exports.BINARY_READ_LENGTH; i++) {
        const characterCode = buffer[i];
        if (characterCode === 65533 || characterCode <= 8) {
          return true;
        }
      }
      return false;
    };
    exports.isBinary = isBinary;
  }
});

// node_modules/validate-image-type/lib/validate-image-type.js
var require_validate_image_type = __commonJS({
  "node_modules/validate-image-type/lib/validate-image-type.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateMIMEType = exports.validateBufferMIMEType = void 0;
    var assert_1 = __importDefault(require_assert());
    var fs = __importStar(require_promises());
    var image_type_1 = require_image_type();
    var isBinary_1 = require_isBinary();
    async function validateBufferMIMEType(buffer, options) {
      const mimeTypes = options.allowMimeTypes;
      assert_1.default.ok(Array.isArray(mimeTypes) && mimeTypes.every((mimeType) => mimeType.includes("/")), `Should be set an array of mimeType. e.g.) ['image/jpeg']`);
      const allowSVG = mimeTypes.includes("image/svg+xml");
      if (allowSVG) {
        const { default: isSvg } = await import("./is-svg-A27Z3BRZ.js");
        if (isSvg(String(buffer))) {
          return {
            ok: true,
            error: void 0
          };
        }
      }
      const imageTypeMime = await (0, image_type_1.imageType)(buffer);
      if (!imageTypeMime) {
        return {
          ok: false,
          error: new Error(`This buffer is not supported image. allowMimeTypes: ${JSON.stringify(mimeTypes)}` + (options.originalFilename ? `, filename: ${options.originalFilename}` : ""))
        };
      }
      const isAllowed = mimeTypes.includes(imageTypeMime);
      if (!isAllowed) {
        return {
          ok: false,
          error: new Error(`This buffer is disallowed image MimeType: ${imageTypeMime}, allowMimeTypes: ${JSON.stringify(mimeTypes)}` + (options.originalFilename ? `,filename: ${options.originalFilename}` : ""))
        };
      }
      return {
        ok: true,
        error: void 0
      };
    }
    exports.validateBufferMIMEType = validateBufferMIMEType;
    async function validateMIMEType(filePath, options) {
      const { readChunk } = await import("./read-chunk-Y7DVDH64.js");
      const buffer = await readChunk(filePath, {
        startPosition: 0,
        length: isBinary_1.BINARY_READ_LENGTH
      });
      if (!(0, isBinary_1.isBinary)(buffer)) {
        const mimeTypes = options.allowMimeTypes;
        const allowSVG = mimeTypes.includes("image/svg+xml");
        if (allowSVG) {
          const { default: isSvg } = await import("./is-svg-A27Z3BRZ.js");
          const content = await fs.readFile(filePath, "utf-8");
          if (!isSvg(content)) {
            return {
              ok: false,
              error: new Error(`This file is not svg. allowMimeTypes: ${JSON.stringify(mimeTypes)}` + (options.originalFilename ? `, filename: ${options.originalFilename}` : ""))
            };
          }
          return {
            ok: true
          };
        }
      }
      return validateBufferMIMEType(buffer, options);
    }
    exports.validateMIMEType = validateMIMEType;
  }
});
export default require_validate_image_type();
//# sourceMappingURL=validate-image-type.js.map
